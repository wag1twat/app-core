{"version":3,"sources":["Base/Array/group-by/group-by.js","../src/Base/Array/group-by/group-by.ts"],"names":["Object","defineProperty","exports","value","Guards_1","require","get_1","groupBy","t","key","map","Map","some","item","Guards","isObject","forEach","collection","k","get","push","set","values","Array","from","entries"],"mappings":"AAAA,aACAA,OAAOC,eAAeC,QAAS,aAAc,CAAEC,MAAO,CAAA,CAAK,CAAC,EAA5DH,QAAOC,QAAAA,KAAAA,ECDP,MAAAG,SAAAC,QAAA,iBAAA,EACAC,MAAAD,QAAA,kBAAA,EAGME,QAAU,SAAuDC,EAAMC,GACzE,MAAMC,EAAM,IAAIC,IAwBhB,OAtBIH,EAAEI,KAAMC,GAAS,CAACT,SAAAU,OAAOC,SAASF,CAAI,CAAC,GAQ3CL,EAAEQ,QAASH,IACP,IAGUI,EAHJC,GAAI,EAAAZ,MAAAa,KAAIN,CAAI,EAAEJ,CAAG,EAEnBS,KACMD,EAAaP,EAAIS,IAAID,CAAC,GAKxBD,EAAWG,KAAKP,CAAI,EAFpBH,EAAIW,IAAIH,EAAG,CAACL,EAAK,EAK7B,CAAC,EAEM,CACHH,IAAAA,EACAY,OAAQC,MAAMC,KAAKd,EAAIY,OAAM,CAAE,EAC/BG,QAASF,MAAMC,KAAKd,EAAIe,QAAO,CAAE,CADjCH,CAGR,EAESpB,QAAAK,QAAAA","file":"group-by.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.groupBy = void 0;\nconst Guards_1 = require(\"../../../Guards\");\nconst get_1 = require(\"../../Object/get\");\nconst groupBy = function (t, key) {\n    const map = new Map();\n    if (t.some((item) => !Guards_1.Guards.isObject(item))) {\n        return {\n            map,\n            values: Array.from(map.values()),\n            entries: Array.from(map.entries()),\n        };\n    }\n    t.forEach((item) => {\n        const k = (0, get_1.get)(item)(key);\n        if (k) {\n            const collection = map.get(k);\n            if (!collection) {\n                map.set(k, [item]);\n            }\n            else {\n                collection.push(item);\n            }\n        }\n    });\n    return {\n        map,\n        values: Array.from(map.values()),\n        entries: Array.from(map.entries()),\n    };\n};\nexports.groupBy = groupBy;\n","import { Guards } from '../../../Guards'\nimport { get } from '../../Object/get'\nimport { ArrayOf, Path, PathValue } from '../../types'\n\nconst groupBy = function <T extends any[], K extends Path<ArrayOf<T>>>(t: T, key: K) {\n    const map = new Map<PathValue<ArrayOf<T>, K>, ArrayOf<T>[]>()\n\n    if (t.some((item) => !Guards.isObject(item))) {\n        return {\n            map,\n            values: Array.from(map.values()),\n            entries: Array.from(map.entries()),\n        }\n    }\n\n    t.forEach((item) => {\n        const k = get(item)(key)\n\n        if (k) {\n            const collection = map.get(k)\n\n            if (!collection) {\n                map.set(k, [item])\n            } else {\n                collection.push(item)\n            }\n        }\n    })\n\n    return {\n        map,\n        values: Array.from(map.values()),\n        entries: Array.from(map.entries()),\n    }\n}\n\nexport { groupBy }\n"]}