{"version":3,"sources":["Base/Array/create-sort/create-sort.js","../src/Base/Array/create-sort/create-sort.ts"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","createSort","Types_1","require","Guards_1","get_xpath_1","get_compare_function_1","collection","options","let","called","field","order","orders","onUpdate","state","slice","Types","Array","Sort","defaultOrder","defaultOrders","undefined","onUpdateCallback","Guards","isFunc","getValue","item","isString","default","isObject","handler","xpath","setField","isUndefined","setOrder","noUpdateOrderFalsyEqualXPath","is","lastOrderIndex","length","nextOrderIndex","indexOf","update","sort","l","r","cleanup"],"mappings":"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","file":"create-sort.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSort = void 0;\nconst Types_1 = require(\"../../Types\");\nconst Guards_1 = require(\"../../../Guards\");\nconst get_xpath_1 = __importDefault(require(\"../../Object/get-xpath\"));\nconst get_compare_function_1 = __importDefault(require(\"./get-compare-function\"));\nconst createSort = (collection) => {\n    return (options) => {\n        let called = false;\n        const { field, order, orders, onUpdate } = options;\n        const state = {\n            collection: collection.slice(),\n            order: order ? order : Types_1.Types.Array.Sort.defaultOrder,\n            orders: orders ? orders : Types_1.Types.Array.Sort.defaultOrders,\n            field: field ? field : undefined,\n        };\n        //callbacks\n        const onUpdateCallback = () => {\n            if (Guards_1.Guards.isFunc(onUpdate)) {\n                onUpdate(state);\n            }\n        };\n        // utilities\n        const getValue = (item) => {\n            if (Guards_1.Guards.isString(state.field)) {\n                return (0, get_xpath_1.default)(item)(state.field);\n            }\n            if (Guards_1.Guards.isObject(state.field)) {\n                return state.field.handler((0, get_xpath_1.default)(item)(state.field.xpath));\n            }\n            return item;\n        };\n        const cleanup = () => {\n            state.field = field ? field : undefined;\n            state.order = order ? order : Types_1.Types.Array.Sort.defaultOrder;\n            state.orders = orders ? orders : Types_1.Types.Array.Sort.defaultOrders;\n            state.collection = collection.slice();\n            onUpdateCallback();\n        };\n        const setField = (field) => {\n            if (!Guards_1.Guards.isUndefined(field)) {\n                state.field = field;\n            }\n        };\n        const setOrder = (field, noUpdateOrderFalsyEqualXPath) => {\n            let is = false;\n            if (noUpdateOrderFalsyEqualXPath) {\n                if (Guards_1.Guards.isString(state.field) && Guards_1.Guards.isString(field)) {\n                    if (state.field === field) {\n                        is = true && called;\n                    }\n                }\n                else if (Guards_1.Guards.isString(state.field) && Guards_1.Guards.isObject(field)) {\n                    if (state.field === field.xpath) {\n                        is = true && called;\n                    }\n                }\n                else if (Guards_1.Guards.isObject(state.field) && Guards_1.Guards.isString(field)) {\n                    if (state.field.xpath === field) {\n                        is = true && called;\n                    }\n                }\n                else if (Guards_1.Guards.isObject(state.field) && Guards_1.Guards.isObject(field)) {\n                    if (state.field.xpath === field.xpath) {\n                        is = true && called;\n                    }\n                }\n            }\n            else {\n                is = true && called;\n            }\n            if (is) {\n                const lastOrderIndex = state.orders.length - 1;\n                const currentOrderIndex = state.orders.indexOf(state.order);\n                const nextOrderIndex = currentOrderIndex + 1;\n                state.order =\n                    nextOrderIndex <= lastOrderIndex\n                        ? state.orders[nextOrderIndex]\n                        : state.orders[0];\n            }\n        };\n        const update = (options = {}) => {\n            const { field, noUpdateOrderFalsyEqualXPath = false } = options;\n            setOrder(field, noUpdateOrderFalsyEqualXPath);\n            setField(field);\n            if (state.order === 'default') {\n                state.collection = collection.slice();\n                onUpdateCallback();\n            }\n            else {\n                state.collection = state.collection.slice().sort((l, r) => (0, get_compare_function_1.default)(state.order, getValue(l), getValue(r)));\n                onUpdateCallback();\n            }\n        };\n        if (!called) {\n            update({\n                field,\n            });\n            called = true;\n        }\n        return {\n            cleanup,\n            update,\n        };\n    };\n};\nexports.createSort = createSort;\n","import { Types } from '../../Types'\nimport { Guards } from '../../../Guards'\nimport getXPath from '../../Object/get-xpath'\nimport getCompareFunction from './get-compare-function'\n\nconst createSort = <T extends any[]>(collection: T) => {\n    return <XPath extends Types.Utility.JSONPath<Types.Array.Of<T>>>(\n        options: Types.Array.Sort.Options<T, XPath>\n    ) => {\n        let called: boolean = false\n\n        const { field, order, orders, onUpdate } = options\n\n        const state: Types.Array.Sort.State<T> = {\n            collection: collection.slice() as T,\n            order: order ? order : Types.Array.Sort.defaultOrder,\n            orders: orders ? orders : Types.Array.Sort.defaultOrders,\n            field: field ? field : undefined,\n        }\n\n        //callbacks\n        const onUpdateCallback = () => {\n            if (Guards.isFunc(onUpdate)) {\n                onUpdate(state)\n            }\n        }\n        // utilities\n        const getValue = (item: Types.Array.Of<T>) => {\n            if (Guards.isString(state.field)) {\n                return getXPath(item)(state.field)\n            }\n            if (Guards.isObject(state.field)) {\n                return state.field.handler(getXPath(item)(state.field.xpath))\n            }\n            return item\n        }\n\n        const cleanup = () => {\n            state.field = field ? field : undefined\n            state.order = order ? order : Types.Array.Sort.defaultOrder\n            state.orders = orders ? orders : Types.Array.Sort.defaultOrders\n            state.collection = collection.slice() as T\n            onUpdateCallback()\n        }\n\n        const setField = <XPath extends Types.Utility.JSONPath<Types.Array.Of<T>>>(\n            field: Types.Array.Sort.Field<T, XPath> | undefined\n        ) => {\n            if (!Guards.isUndefined(field)) {\n                state.field = field\n            }\n        }\n\n        const setOrder = <XPath extends Types.Utility.JSONPath<Types.Array.Of<T>>>(\n            field: Types.Array.Sort.Field<T, XPath> | undefined,\n            noUpdateOrderFalsyEqualXPath: boolean\n        ) => {\n            let is: boolean = false\n\n            if (noUpdateOrderFalsyEqualXPath) {\n                if (Guards.isString(state.field) && Guards.isString(field)) {\n                    if (state.field === field) {\n                        is = true && called\n                    }\n                } else if (Guards.isString(state.field) && Guards.isObject(field)) {\n                    if (state.field === field.xpath) {\n                        is = true && called\n                    }\n                } else if (Guards.isObject(state.field) && Guards.isString(field)) {\n                    if (state.field.xpath === field) {\n                        is = true && called\n                    }\n                } else if (Guards.isObject(state.field) && Guards.isObject(field)) {\n                    if (state.field.xpath === field.xpath) {\n                        is = true && called\n                    }\n                }\n            } else {\n                is = true && called\n            }\n\n            if (is) {\n                const lastOrderIndex = state.orders.length - 1\n                const currentOrderIndex = state.orders.indexOf(state.order)\n                const nextOrderIndex = currentOrderIndex + 1\n                state.order =\n                    nextOrderIndex <= lastOrderIndex\n                        ? state.orders[nextOrderIndex]\n                        : state.orders[0]\n            }\n        }\n\n        const update = <XPath extends Types.Utility.JSONPath<Types.Array.Of<T>>>(\n            options: Types.Array.Sort.UpdateOptions<T, XPath> = {}\n        ) => {\n            const { field, noUpdateOrderFalsyEqualXPath = false } = options\n\n            setOrder(field, noUpdateOrderFalsyEqualXPath)\n\n            setField(field)\n\n            if (state.order === 'default') {\n                state.collection = collection.slice() as T\n                onUpdateCallback()\n            } else {\n                state.collection = (state.collection.slice() as T).sort((l, r) =>\n                    getCompareFunction(\n                        state.order as Exclude<Types.Array.Sort.Order, 'default'>,\n                        getValue(l),\n                        getValue(r)\n                    )\n                )\n                onUpdateCallback()\n            }\n        }\n\n        if (!called) {\n            update({\n                field,\n            })\n            called = true\n        }\n\n        return {\n            cleanup,\n            update,\n        }\n    }\n}\n\nexport { createSort }\n"]}