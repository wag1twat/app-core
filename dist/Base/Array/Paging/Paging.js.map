{"version":3,"sources":["Base/Array/Paging/Paging.js","../src/Base/Array/Paging/Paging.ts"],"names":["Object","defineProperty","exports","value","Guards_1","require","Paging","state","options","pagingPage","pagingPages","constructor","this","page","startsWith","isFirstPage","isLastPage","isFirstPagingPage","isLastPagingPage","pages","setState","bind","getPagesCount","getPagingPages","nextPage","prevPage","nextPagingPage","prevPagingPage","updatePage","updatePagingPage","Guards","isBoolean","onMount","nextState","isFunc","onPagingUpdate","Math","ceil","itemsCount","pageSize","length","Array","from","keys","map","let","i","paginationSize","slice","count","canUpdate","includes","index","findIndex","x","paging"],"mappings":"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","file":"Paging.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Paging = exports.paging = void 0;\nconst Guards_1 = require(\"../../../Guards\");\nclass Paging {\n    state;\n    options;\n    pagingPage = 1;\n    pagingPages = [];\n    constructor(options) {\n        this.state = {\n            page: options.startsWith || 1,\n            isFirstPage: true,\n            isLastPage: false,\n            isFirstPagingPage: true,\n            isLastPagingPage: false,\n            pages: [],\n        };\n        this.options = options;\n        this.setState = this.setState.bind(this);\n        this.getPagesCount = this.getPagesCount.bind(this);\n        this.getPagingPages = this.getPagingPages.bind(this);\n        this.pagingPages = this.getPagingPages();\n        this.nextPage = this.nextPage.bind(this);\n        this.prevPage = this.prevPage.bind(this);\n        this.nextPagingPage = this.nextPagingPage.bind(this);\n        this.prevPagingPage = this.prevPagingPage.bind(this);\n        this.updatePage = this.updatePage.bind(this);\n        this.updatePagingPage = this.updatePagingPage.bind(this);\n        this.isFirstPage = this.isFirstPage.bind(this);\n        this.isLastPage = this.isLastPage.bind(this);\n        this.isFirstPagingPage = this.isFirstPagingPage.bind(this);\n        this.isLastPagingPage = this.isLastPagingPage.bind(this);\n        if (Guards_1.Guards.isBoolean(this.options.onMount)) {\n            if (this.options.onMount) {\n                this.updatePage(this.state.page);\n            }\n        }\n        else {\n            this.updatePage(this.state.page);\n        }\n    }\n    setState(nextState) {\n        this.state = { ...this.state, ...nextState };\n        if (Guards_1.Guards.isFunc(this.options.onPagingUpdate)) {\n            this.options.onPagingUpdate(this.state);\n        }\n    }\n    getPagesCount() {\n        return Math.ceil(this.options.itemsCount / this.options.pageSize);\n    }\n    isFirstPage = (page) => page === 1;\n    isLastPage = (page) => page === this.getPagesCount();\n    isFirstPagingPage = (pagingPage) => pagingPage === 1;\n    isLastPagingPage = (pagingPage) => pagingPage === this.pagingPages.length;\n    getPagingPages() {\n        const pages = Array.from(Array(this.getPagesCount()).keys()).map((page) => page + 1);\n        const pagingPages = [];\n        for (let i = 0; i < Math.ceil(pages.length / this.options.paginationSize); i++) {\n            pagingPages[i] = pages.slice(i * this.options.paginationSize, i * this.options.paginationSize + this.options.paginationSize);\n        }\n        return pagingPages;\n    }\n    updatePagingPage(pagingPage) {\n        const count = this.pagingPages.length;\n        const canUpdate = pagingPage >= 1 && count >= pagingPage;\n        if (canUpdate) {\n            this.pagingPage = pagingPage;\n            this.setState({\n                pages: this.pagingPages[this.pagingPage - 1],\n                isFirstPagingPage: this.isFirstPagingPage(pagingPage),\n                isLastPagingPage: this.isLastPagingPage(pagingPage),\n            });\n        }\n    }\n    nextPagingPage() {\n        this.updatePagingPage(this.pagingPage + 1);\n    }\n    prevPagingPage() {\n        this.updatePagingPage(this.pagingPage + 1);\n    }\n    updatePage(page) {\n        const count = this.getPagesCount();\n        const canUpdate = page >= 1 && count >= page;\n        if (canUpdate) {\n            this.setState({\n                page,\n                isFirstPage: this.isFirstPage(page),\n                isLastPage: this.isLastPage(page),\n            });\n            if (!this.state.pages.includes(page)) {\n                const index = this.pagingPages.findIndex((x) => x.includes(this.state.page));\n                this.pagingPage = index + 1;\n                this.setState({\n                    pages: this.pagingPages[index],\n                    isFirstPagingPage: this.isFirstPagingPage(this.pagingPage),\n                    isLastPagingPage: this.isLastPagingPage(this.pagingPage),\n                });\n            }\n        }\n    }\n    nextPage() {\n        this.updatePage(this.state.page + 1);\n    }\n    prevPage() {\n        this.updatePage(this.state.page - 1);\n    }\n}\nexports.Paging = Paging;\nconst paging = (options) => new Paging(options);\nexports.paging = paging;\n","import { Guards } from '../../../Guards'\nimport { PagingOptions, PagingState, PublicPagingMethods } from './types'\n\nclass Paging implements PublicPagingMethods {\n    private state: PagingState\n    private options: PagingOptions\n    private pagingPage: number = 1\n    private pagingPages: number[][] = []\n    constructor(options: PagingOptions) {\n        this.state = {\n            page: options.startsWith || 1,\n            isFirstPage: true,\n            isLastPage: false,\n            isFirstPagingPage: true,\n            isLastPagingPage: false,\n            pages: [],\n        }\n        this.options = options\n        this.setState = this.setState.bind(this)\n        this.getPagesCount = this.getPagesCount.bind(this)\n        this.getPagingPages = this.getPagingPages.bind(this)\n        this.pagingPages = this.getPagingPages()\n        this.nextPage = this.nextPage.bind(this)\n        this.prevPage = this.prevPage.bind(this)\n        this.nextPagingPage = this.nextPagingPage.bind(this)\n        this.prevPagingPage = this.prevPagingPage.bind(this)\n        this.updatePage = this.updatePage.bind(this)\n        this.updatePagingPage = this.updatePagingPage.bind(this)\n        this.isFirstPage = this.isFirstPage.bind(this)\n        this.isLastPage = this.isLastPage.bind(this)\n        this.isFirstPagingPage = this.isFirstPagingPage.bind(this)\n        this.isLastPagingPage = this.isLastPagingPage.bind(this)\n\n        if (Guards.isBoolean(this.options.onMount)) {\n            if (this.options.onMount) {\n                this.updatePage(this.state.page)\n            }\n        } else {\n            this.updatePage(this.state.page)\n        }\n    }\n    private setState(nextState: Partial<PagingState>) {\n        this.state = { ...this.state, ...nextState }\n\n        if (Guards.isFunc(this.options.onPagingUpdate)) {\n            this.options.onPagingUpdate(this.state)\n        }\n    }\n    private getPagesCount() {\n        return Math.ceil(this.options.itemsCount / this.options.pageSize)\n    }\n    private isFirstPage = (page: number) => page === 1\n    private isLastPage = (page: number) => page === this.getPagesCount()\n    private isFirstPagingPage = (pagingPage: number) => pagingPage === 1\n    private isLastPagingPage = (pagingPage: number) => pagingPage === this.pagingPages.length\n    private getPagingPages() {\n        const pages = Array.from(Array(this.getPagesCount()).keys()).map((page) => page + 1)\n        const pagingPages = []\n        for (let i = 0; i < Math.ceil(pages.length / this.options.paginationSize); i++) {\n            pagingPages[i] = pages.slice(\n                i * this.options.paginationSize,\n                i * this.options.paginationSize + this.options.paginationSize\n            )\n        }\n        return pagingPages\n    }\n    private updatePagingPage(pagingPage: number) {\n        const count = this.pagingPages.length\n        const canUpdate = pagingPage >= 1 && count >= pagingPage\n        if (canUpdate) {\n            this.pagingPage = pagingPage\n            this.setState({\n                pages: this.pagingPages[this.pagingPage - 1],\n                isFirstPagingPage: this.isFirstPagingPage(pagingPage),\n                isLastPagingPage: this.isLastPagingPage(pagingPage),\n            })\n        }\n    }\n    public nextPagingPage() {\n        this.updatePagingPage(this.pagingPage + 1)\n    }\n    public prevPagingPage() {\n        this.updatePagingPage(this.pagingPage + 1)\n    }\n\n    public updatePage(page: number) {\n        const count = this.getPagesCount()\n        const canUpdate = page >= 1 && count >= page\n\n        if (canUpdate) {\n            this.setState({\n                page,\n                isFirstPage: this.isFirstPage(page),\n                isLastPage: this.isLastPage(page),\n            })\n\n            if (!this.state.pages.includes(page)) {\n                const index = this.pagingPages.findIndex((x) => x.includes(this.state.page))\n                this.pagingPage = index + 1\n                this.setState({\n                    pages: this.pagingPages[index],\n                    isFirstPagingPage: this.isFirstPagingPage(this.pagingPage),\n                    isLastPagingPage: this.isLastPagingPage(this.pagingPage),\n                })\n            }\n        }\n    }\n    public nextPage() {\n        this.updatePage(this.state.page + 1)\n    }\n    public prevPage() {\n        this.updatePage(this.state.page - 1)\n    }\n}\n\nconst paging = (options: PagingOptions): PublicPagingMethods => new Paging(options)\n\nexport { paging, Paging }\n"]}