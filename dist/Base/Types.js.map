{"version":3,"sources":["Base/Types.js","../src/Base/Types.ts"],"names":["Types","Object","defineProperty","exports","value","let","Array","defaultToQueriesOptions","skipNull","skipUndefined","arrayAccsessor","objectAccsessor","toQueriesAccsessors",".","[]","{}","Sort","defaultOrders","defaultOrder"],"mappings":"AAAA,aCAA,IAAiBA,MDCjBC,OAAOC,eAAeC,QAAS,aAAc,CAAEC,MAAO,CAAA,CAAK,CAAC,EAA5DH,QAAOC,MAAAA,KAAAA,ECDP,SAAiBF,GAmDbK,IAqBiBC,GArBAL,EAAAD,EAAAC,SAAAD,EAAAC,OAAM,KAQNM,wBAA4C,CACrDC,SAAU,CAAA,EACVC,cAAe,CAAA,EACfC,eAAgB,KAChBC,gBAAiB,GAFjBF,EAKSR,EAAAW,oBAAsB,CAC/BC,IAAK,CAAC,IAAK,IACXC,KAAM,CAAC,IAAK,KACZC,KAAM,CAAC,IAAK,IAFZ,GAOaC,GAFJV,EAAAN,EAAAM,QAAAN,EAAAM,MAAK,KAEDU,OAAAV,EAAAU,KAAI,KA+BJC,cAAyB,CAAC,MAAO,OAAQ,WAEzCD,EAAAE,aAAsB,SAiC9C,EA5IgBlB,MAAAG,QAAAH,QAAAG,QAAAH,MAAK,GAAA","file":"Types.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Types = void 0;\nvar Types;\n(function (Types) {\n    let Object;\n    (function (Object) {\n        Object.defaultToQueriesOptions = {\n            skipNull: true,\n            skipUndefined: true,\n            arrayAccsessor: '[]',\n            objectAccsessor: '.',\n        };\n        Object.toQueriesAccsessors = {\n            '.': ['.', ''],\n            '[]': ['[', ']'],\n            '{}': ['{', '}'],\n        };\n    })(Object = Types.Object || (Types.Object = {}));\n    let Array;\n    (function (Array) {\n        let Sort;\n        (function (Sort) {\n            Sort.defaultOrders = ['ASC', 'DESC', 'default'];\n            Sort.defaultOrder = 'default';\n        })(Sort = Array.Sort || (Array.Sort = {}));\n    })(Array = Types.Array || (Types.Array = {}));\n})(Types = exports.Types || (exports.Types = {}));\n","export namespace Types {\n    export namespace Utility {\n        export type IsAny<T> = unknown extends T & string ? true : false\n\n        export type StringOrNumber = string | number\n\n        export type Primitive = string | number | bigint | boolean | undefined | symbol\n\n        // TODO: array path\n        export type JSONPath<T, Prefix = ''> = {\n            [K in keyof T]: T[K] extends Primitive | Array<any>\n                ? `${string & Prefix}${string & K}`\n                :\n                      | `${string & Prefix}${string & K}`\n                      | (IsAny<T[K]> extends false\n                            ? JSONPath<T[K], `${string & Prefix}${string & K}.`>\n                            : never)\n        }[keyof T]\n\n        export type JSONFind<\n            T extends Record<string, any>,\n            Path = JSONPath<T>\n        > = Path extends keyof T\n            ? T[Path]\n            : Path extends `${infer Up}.${infer Down}`\n            ? IsAny<T[Up]> extends false\n                ? JSONFind<T[Up], Down>\n                : never\n            : never\n    }\n    export namespace String {\n        export type Split<S extends string, D extends string> = string extends S\n            ? string[]\n            : S extends ''\n            ? []\n            : S extends `${infer T}${D}${infer U}`\n            ? [T, ...Split<U, D>]\n            : [S]\n\n        export type ReplaceAll<\n            T extends string,\n            M extends { [k: string]: string },\n            A extends string = ''\n        > = T extends `${Extract<keyof M, string>}${infer R}`\n            ? T extends `${infer K}${R}`\n                ? ReplaceAll<R, M, `${A}${M[Extract<K, keyof M>]}`>\n                : never\n            : T extends `${infer F}${infer R}`\n            ? ReplaceAll<R, M, `${A}${F}`>\n            : A\n    }\n    export namespace Object {\n        export interface ToQueriesOptions {\n            objectAccsessor: '.' | '{}' | '[]'\n            arrayAccsessor: '.' | '{}' | '[]'\n            skipUndefined: boolean\n            skipNull: boolean\n        }\n\n        export const defaultToQueriesOptions: ToQueriesOptions = {\n            skipNull: true,\n            skipUndefined: true,\n            arrayAccsessor: '[]',\n            objectAccsessor: '.',\n        }\n\n        export const toQueriesAccsessors = {\n            '.': ['.', ''] as const,\n            '[]': ['[', ']'] as const,\n            '{}': ['{', '}'] as const,\n        }\n    }\n    export namespace Array {\n        export type Of<T extends any[]> = T extends (infer U)[] ? U : never\n        export namespace Sort {\n            export type Order = 'ASC' | 'DESC' | 'default'\n\n            export type FieldObject<T extends any[], XPath extends Utility.JSONPath<Of<T>>> = {\n                xpath: XPath\n                handler: (item: Utility.JSONFind<Of<T>, XPath> | undefined) => Utility.Primitive\n            }\n\n            export type Field<T extends any[], XPath extends Utility.JSONPath<Of<T>>> =\n                | XPath\n                | FieldObject<T, XPath>\n\n            export type State<T extends any[]> = {\n                collection: T\n                order: Order\n                orders: Order[]\n                field?: Field<T, Utility.JSONPath<Of<T>>>\n            }\n\n            export type Options<T extends any[], XPath extends Utility.JSONPath<Of<T>>> = {\n                field?: Field<T, XPath>\n                order?: Order\n                orders?: Order[]\n                onUpdate: (state: State<T>) => void\n            }\n\n            export type UpdateOptions<T extends any[], XPath extends Utility.JSONPath<Of<T>>> = {\n                field?: Field<T, XPath>\n                noUpdateOrderFalsyEqualXPath?: boolean\n            }\n\n            export const defaultOrders: Order[] = ['ASC', 'DESC', 'default']\n\n            export const defaultOrder: Order = 'default'\n        }\n        export namespace Paging {\n            export type State = {\n                page: number\n                isFirstPage: boolean\n                isLastPage: boolean\n                _pagingPage: number\n                isFirstPagingPage: boolean\n                isLastPagingPage: boolean\n                _pagingPages: number[][]\n                pages: number[]\n            }\n\n            export type Options = {\n                itemsCount: number\n                page?: number\n                pageSize: number\n                paginationSize: number\n                onMount?: boolean\n                onPagingUpdate?: (state: State) => void\n            }\n        }\n        export namespace CreatePaging {\n            export type State<T extends any[]> = Paging.State & {\n                collection: T\n            }\n            export interface Options<T extends any[]>\n                extends Pick<Paging.Options, 'page' | 'pageSize' | 'paginationSize' | 'onMount'> {\n                onPagingUpdate: (state: State<T>) => void\n            }\n        }\n    }\n}\n"]}