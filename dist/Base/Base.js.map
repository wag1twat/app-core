{"version":3,"sources":["Base/Base.js","../lib/Base/Base.ts"],"names":["Object","defineProperty","exports","value","Guards_1","require","rules_1","Types_1","Base","obj","get","key","toQueries","options","Types","defaultToQueriesOptions","prefix","skipNull","skipUndefined","let","result","hasOwnProperty","pre","post","Guards","isNull","isUndefined","accsessor","isArrayConstructor","toQueriesAccsessors","arrayAccsessor","isObjectConstructor","objectAccsessor","isTypeofObject","push","encodeURIComponent","filter","nonEmptyString","concat","apply","length","join","String","string","hasQueryParams","indexOf","split","separator","limit","replaceAllSeparatedString","properties","parts","i","property","joinQueryString","queryString"],"mappings":"AAAA,aACAA,OAAOC,eAAeC,QAAS,aAAc,CAAEC,MAAO,CAAA,CAAK,CAAC,EAA5DH,QAAOC,KAAAA,KAAAA,ECDP,MAAAG,SAAAC,QAAA,WAAA,EACAC,QAAAD,QAAA,SAAA,EACAE,QAAAF,QAAA,SAAA,EAIA,IAAUG,KAAV,CAAA,SAAUA,GACUA,EAAAR,OAAhB,SAAgBA,EAAyBS,GACrC,SAASC,EAAsBC,GAC3B,OAAOF,EAAIE,EACf,CAgDA,MAAO,CACHD,IAAAA,EACAE,UAhDJ,SAAmBC,EAAkDN,QAAAO,MAAMd,OAAOe,wBAAyBC,GACvG,IAIQL,EAJF,CAAEM,SAAAA,EAAUC,cAAAA,CAAa,EAAKL,EAEpCM,IAAIC,EAAmB,GAEvB,IAAQT,KAAOF,EACX,GAAGA,EAAIY,eAAeV,CAAG,EAAzB,CACI,IAgBWW,EAAKC,EAhBVpB,EAAQO,EAAIC,CAAG,EAErB,GAAGM,EAAa,CAAA,IAAbA,GAAqBb,SAAAoB,OAAOC,OAAOtB,CAAK,GAGjB,CAAA,IAAlBe,GAA0Bd,SAAAoB,OAAOE,YAAYvB,CAAK,GAArD,CAILgB,IAAIQ,EAAoBhB,EAErBP,SAAAoB,OAAOI,mBAAmBnB,CAAG,GACtB,CAACa,EAAKC,GAAQhB,QAAAO,MAAMd,OAAO6B,oBAAoBhB,EAAQiB,gBAAkBvB,QAAAO,MAAMd,OAAOe,wBAAwBe,gBACpHH,EAAY,GAAGX,EAASM,EAAMC,GAE1BnB,SAAAoB,OAAOO,oBAAoBtB,CAAG,IAC5B,CAACa,EAAKC,GAAQhB,QAAAO,MAAMd,OAAO6B,oBAAoBhB,EAAQmB,iBAAmBzB,QAAAO,MAAMd,OAAOe,wBAAwBiB,iBACrHL,EAAaX,EAAS,GAAGA,EAASM,EAAMK,EAAYJ,EAASI,GAG9DvB,SAAAoB,OAAOS,eAAe9B,CAAK,EAC1BiB,EAAOc,KAAKlC,EAAOG,CAAK,EAAES,UAAUC,EAASc,CAAS,CAAC,EAGvDP,EAAOc,KAAQP,EAAH,IAAgBQ,mBAAmB,GAAGhC,CAAO,CAAG,CAxB1DA,CA2BL,CAST,OAJAiB,EAASA,EAAOgB,OAAO9B,QAAA+B,cAAc,GAErCjB,EAAU,GAAgBkB,OAAOC,MAAM,GAAgBnB,CAAM,GAE/CoB,OAASpB,EAAOqB,KAAK,GAAG,EAAI,EAC9C,CAGI/B,CAGR,EAEgBF,EAAAkC,OAAhB,SAAyCC,GACrC,SAASC,IACL,MAAoC,CAAC,KAA9B,GAAGD,GAASE,QAAQ,GAAG,CAClC,CAOA,SAASC,EAAgCC,EAAmBC,GACxD,OAAO,GAAGL,GAASG,MAAMC,EAAWC,CAAK,CAC7C,CAqBA,MAAO,CACHF,MAAAA,EACAG,0BArBJ,SACCF,EAAsBG,GACnB,IAAM9B,EAAS,GAET+B,EAAQL,EAAMC,CAAS,EAE7B,IAAI5B,IAAIiC,EAAI,EAAGA,EAAID,EAAMX,OAAQY,CAAC,GAAI,CAClC,IAAMC,EAAW7C,EAAKR,OAAUkD,CAAU,EAAExC,IAAIyC,EAAMC,EAAE,EAErD5C,EAAKR,OAAUkD,CAAU,EAAExC,IAAIyC,EAAMC,EAAE,EACtChC,EAAOc,KAAKmB,CAAQ,EAEpBjC,EAAOc,KAAKiB,EAAMC,EAAE,CDfxB,CCmBJ,OAAOhC,EAAOqB,KAAKM,CAAS,CAChC,EAKIH,eAAAA,EACAU,gBAhCJ,SAA2CC,GAEvC,OADyBX,EAAc,EACVD,EAAH,IAAaY,EAAmBZ,EAAH,IAAaY,CACxE,CA6BID,CAER,CACH,EAlGS9C,KAAAA,MAAI,EAAA,EAoGLN,QAAAM,KAAAA","file":"Base.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Base = void 0;\nconst Guards_1 = require(\"../Guards\");\nconst rules_1 = require(\"./rules\");\nconst Types_1 = require(\"./Types\");\nvar Base;\n(function (Base) {\n    function Object(obj) {\n        function get(key) {\n            return obj[key];\n        }\n        function toQueries(options = Types_1.Types.Object.defaultToQueriesOptions, prefix) {\n            const { skipNull, skipUndefined } = options;\n            let result = [];\n            for (let key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    const value = get(key);\n                    if (skipNull === true && Guards_1.Guards.isNull(value)) {\n                        continue;\n                    }\n                    else if (skipUndefined === true && Guards_1.Guards.isUndefined(value)) {\n                        continue;\n                    }\n                    let accsessor = key;\n                    if (Guards_1.Guards.isArrayConstructor(obj)) {\n                        const [pre, post] = Types_1.Types.Object.toQueriesAccsessors[options.arrayAccsessor || Types_1.Types.Object.defaultToQueriesOptions.arrayAccsessor];\n                        accsessor = `${prefix}${pre}${post}`;\n                    }\n                    else if (Guards_1.Guards.isObjectConstructor(obj)) {\n                        const [pre, post] = Types_1.Types.Object.toQueriesAccsessors[options.objectAccsessor || Types_1.Types.Object.defaultToQueriesOptions.objectAccsessor];\n                        accsessor = (prefix ? `${prefix}${pre}${accsessor}${post}` : accsessor);\n                    }\n                    if (Guards_1.Guards.isTypeofObject(value)) {\n                        result.push(Object(value).toQueries(options, accsessor));\n                    }\n                    else {\n                        result.push(`${accsessor}=${encodeURIComponent(`${value}`)}`);\n                    }\n                }\n                else {\n                    continue;\n                }\n            }\n            result = result.filter(rules_1.nonEmptyString);\n            result = [].concat.apply([], result);\n            return result.length ? result.join('&') : \"\";\n        }\n        return {\n            get,\n            toQueries\n        };\n    }\n    Base.Object = Object;\n    function String(string) {\n        function hasQueryParams() {\n            return `${string}`.indexOf('?') !== -1;\n        }\n        function joinQueryString(queryString) {\n            const isHasQueryParams = hasQueryParams();\n            return isHasQueryParams ? `${string}&${queryString}` : `${string}?${queryString}`;\n        }\n        function split(separator, limit) {\n            return `${string}`.split(separator, limit);\n        }\n        function replaceAllSeparatedString(separator, properties) {\n            const result = [];\n            const parts = split(separator);\n            for (let i = 0; i < parts.length; i++) {\n                const property = Base.Object(properties).get(parts[i]);\n                if (Base.Object(properties).get(parts[i])) {\n                    result.push(property);\n                }\n                else {\n                    result.push(parts[i]);\n                }\n            }\n            return result.join(separator);\n        }\n        return {\n            split,\n            replaceAllSeparatedString,\n            hasQueryParams,\n            joinQueryString\n        };\n    }\n    Base.String = String;\n})(Base || (Base = {}));\nexports.Base = Base;\n","import { Guards } from \"../Guards\"\r\nimport { nonEmptyString } from './rules'\r\nimport { Types } from \"./Types\"\r\n\r\n\r\n\r\nnamespace Base {\r\n    export function Object<O extends object>(obj: O) {\r\n        function get<K extends string>(key: K | keyof O){\r\n            return obj[key as Exclude<typeof key, K>]\r\n        }\r\n\r\n        function toQueries(options: Partial<Types.Object.ToQueriesOptions> = Types.Object.defaultToQueriesOptions, prefix?: string): string {\r\n            const { skipNull, skipUndefined } = options\r\n\r\n            let result: string[] = []\r\n\r\n            for(let key in obj) {\r\n                if(obj.hasOwnProperty(key)) {\r\n                    const value = get(key)\r\n\r\n                    if(skipNull === true && Guards.isNull(value)) {\r\n                        continue\r\n                    }\r\n                    else if(skipUndefined === true && Guards.isUndefined(value)){\r\n                        continue\r\n                    }\r\n\r\n                    let accsessor: string = key\r\n\r\n                    if(Guards.isArrayConstructor(obj)) {\r\n                        const [pre, post] = Types.Object.toQueriesAccsessors[options.arrayAccsessor || Types.Object.defaultToQueriesOptions.arrayAccsessor]\r\n                        accsessor = `${prefix}${pre}${post}`\r\n                    }\r\n                    else if(Guards.isObjectConstructor(obj)) {\r\n                        const [pre, post] = Types.Object.toQueriesAccsessors[options.objectAccsessor || Types.Object.defaultToQueriesOptions.objectAccsessor]\r\n                        accsessor = (prefix ? `${prefix}${pre}${accsessor}${post}` : accsessor);\r\n                    }\r\n                \r\n                    if(Guards.isTypeofObject(value)) {\r\n                        result.push(Object(value).toQueries(options, accsessor)) \r\n                    }\r\n                    else {\r\n                        result.push(`${accsessor}=${encodeURIComponent(`${value}`)}`)\r\n                    }\r\n                } \r\n                else {\r\n                    continue\r\n                }\r\n            }\r\n\r\n            result = result.filter(nonEmptyString)\r\n\r\n            result = ([] as string[]).concat.apply([] as string[], result)\r\n\r\n            return result.length ? result.join('&') : \"\"\r\n        }\r\n\r\n        return {\r\n            get,\r\n            toQueries\r\n        }\r\n    }\r\n\r\n    export function String<S extends string>(string: S) {\r\n        function hasQueryParams() {\r\n            return `${string}`.indexOf('?') !== -1;\r\n        }\r\n\r\n        function joinQueryString<Q extends string>(queryString: Q): S extends `${string}?${string}` ? `${S}&${Q}` : `${S}?${Q}` {\r\n            const isHasQueryParams = hasQueryParams()\r\n            return isHasQueryParams ? `${string}&${queryString}` : `${string}?${queryString}` as any\r\n        }\r\n\r\n        function split<Separator extends string>(separator: string, limit?: number | undefined): Types.String.Split<S, Separator> {\r\n            return `${string}`.split(separator, limit) as any\r\n        }\r\n\r\n        function replaceAllSeparatedString<P extends { [x: string]: any }, Separator extends string = string>\r\n        (separator: Separator, properties: P): Types.String.ReplaceAll<S, P> {\r\n            const result = []\r\n\r\n            const parts = split(separator)\r\n\r\n            for(let i = 0; i < parts.length; i++) {\r\n                const property = Base.Object<P>(properties).get(parts[i])\r\n\r\n                if(Base.Object<P>(properties).get(parts[i])) {\r\n                    result.push(property)\r\n                } else {\r\n                    result.push(parts[i])\r\n                }\r\n            }\r\n\r\n            return result.join(separator) as Types.String.ReplaceAll<S, P>\r\n        }\r\n        \r\n        return {\r\n            split,\r\n            replaceAllSeparatedString,\r\n            hasQueryParams,\r\n            joinQueryString\r\n        }\r\n    }\r\n}\r\n\r\nexport { Base }"]}