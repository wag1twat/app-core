{"version":3,"sources":["../lib/Base/Base.ts"],"names":["Base","_Guards","require","_rules","_Types","Object","obj","get","key","toQueries","options","Types","defaultToQueriesOptions","prefix","skipNull","skipUndefined","let","result","hasOwnProperty","pre","post","value","Guards","isNull","isUndefined","accsessor","isArrayConstructor","toQueriesAccsessors","arrayAccsessor","isObjectConstructor","objectAccsessor","isTypeofObject","push","encodeURIComponent","filter","nonEmptyString","concat","apply","length","join","String","string","hasQueryParams","indexOf","split","separator","limit","replaceAllSeparatedString","properties","parts","i","property","joinQueryString","queryString","exports"],"mappings":"wFAAA,IAMUA,KANVC,QAAAC,QAAA,WAAA,EACAC,OAAAD,QAAA,SAAA,EACAE,OAAAF,QAAA,SAAA,EAIA,CAAA,SAAUF,GACUA,EAAAK,OAAhB,SAAgBA,EAAyBC,GACrC,SAASC,EAAsBC,GAC3B,OAAOF,EAAIE,EACf,CAgDA,MAAO,CACHD,IAAAA,EACAE,UAhDJ,SAAmBC,EAAkDC,OAAAA,MAAMN,OAAOO,wBAAyBC,GACvG,IAIQL,EAJF,CAAEM,SAAAA,EAAUC,cAAAA,CAAa,EAAKL,EAEpCM,IAAIC,EAAmB,GAEvB,IAAQT,KAAOF,EACX,GAAGA,EAAIY,eAAeV,CAAG,EAAzB,CACI,IAgBWW,EAAKC,EAhBVC,EAAQd,EAAIC,CAAG,EAErB,GAAGM,EAAa,CAAA,IAAbA,GAAqBQ,QAAAA,OAAOC,OAAOF,CAAK,GAGjB,CAAA,IAAlBN,GAA0BO,QAAAA,OAAOE,YAAYH,CAAK,GAArD,CAILL,IAAIS,EAAoBjB,EAErBc,QAAAA,OAAOI,mBAAmBpB,CAAG,GACtB,CAACa,EAAKC,GAAQT,OAAAA,MAAMN,OAAOsB,oBAAoBjB,EAAQkB,gBAAkBjB,OAAAA,MAAMN,OAAOO,wBAAwBgB,gBACpHH,EAAY,GAAGZ,EAASM,EAAMC,GAE1BE,QAAAA,OAAOO,oBAAoBvB,CAAG,IAC5B,CAACa,EAAKC,GAAQT,OAAAA,MAAMN,OAAOsB,oBAAoBjB,EAAQoB,iBAAmBnB,OAAAA,MAAMN,OAAOO,wBAAwBkB,iBACrHL,EAAaZ,EAAS,GAAGA,EAASM,EAAMM,EAAYL,EAASK,GAG9DH,QAAAA,OAAOS,eAAeV,CAAK,EAC1BJ,EAAOe,KAAK3B,EAAOgB,CAAK,EAAEZ,UAAUC,EAASe,CAAS,CAAC,EAGvDR,EAAOe,KAAQP,EAAH,IAAgBQ,mBAAmB,GAAGZ,CAAO,CAAG,CA9B7B,CA2B/BJ,CAeZ,OAJAA,EAASA,EAAOiB,OAAOC,OAAAA,cAAc,GAErClB,EAAU,GAAgBmB,OAAOC,MAAM,GAAgBpB,CAAM,GAE/CqB,OAASrB,EAAOsB,KAAK,GAAG,EAAI,EAC9C,CAHItB,CASR,EAEgBjB,EAAAwC,OAAhB,SAAyCC,GACrC,SAASC,IACL,MAAoC,CAAC,KAA9B,GAAGD,GAASE,QAAQ,GAAG,CAClC,CAOA,SAASC,EAAgCC,EAAmBC,GACxD,OAAO,GAAGL,GAASG,MAAMC,EAAWC,CAAK,CAC7C,CAqBA,MAAO,CACHF,MAAAA,EACAG,0BArBJ,SACCF,EAAsBG,GACnB,IAAM/B,EAAS,GAETgC,EAAQL,EAAMC,CAAS,EAE7B,IAAI7B,IAAIkC,EAAI,EAAGA,EAAID,EAAMX,OAAQY,CAAC,GAAI,CAClC,IAAMC,EAAWnD,EAAKK,OAAU2C,CAAU,EAAEzC,IAAI0C,EAAMC,EAAE,EAErDlD,EAAKK,OAAU2C,CAAU,EAAEzC,IAAI0C,EAAMC,EAAE,EACtCjC,EAAOe,KAAKmB,CAAQ,EAEpBlC,EAAOe,KAAKiB,EAAMC,EAAE,CAHrBlD,CAOP,OAAOiB,EAAOsB,KAAKM,CAAS,CAChC,EAKIH,eAAAA,EACAU,gBAhCJ,SAA2CC,GAEvC,OADyBX,EAAc,EACVD,EAAH,IAAaY,EAAmBZ,EAAH,IAAaY,CACxE,CAyBA,CAMJ,CACH,GAAAC,QAAAtD,KAAAA,QAlGasD,QAAAtD,KAAJA,KAAI,GAAA","file":"Base.js","sourcesContent":["import { Guards } from \"../Guards\"\r\nimport { nonEmptyString } from './rules'\r\nimport { Types } from \"./Types\"\r\n\r\n\r\n\r\nnamespace Base {\r\n    export function Object<O extends object>(obj: O) {\r\n        function get<K extends string>(key: K | keyof O){\r\n            return obj[key as Exclude<typeof key, K>]\r\n        }\r\n\r\n        function toQueries(options: Partial<Types.Object.ToQueriesOptions> = Types.Object.defaultToQueriesOptions, prefix?: string): string {\r\n            const { skipNull, skipUndefined } = options\r\n\r\n            let result: string[] = []\r\n\r\n            for(let key in obj) {\r\n                if(obj.hasOwnProperty(key)) {\r\n                    const value = get(key)\r\n\r\n                    if(skipNull === true && Guards.isNull(value)) {\r\n                        continue\r\n                    }\r\n                    else if(skipUndefined === true && Guards.isUndefined(value)){\r\n                        continue\r\n                    }\r\n\r\n                    let accsessor: string = key\r\n\r\n                    if(Guards.isArrayConstructor(obj)) {\r\n                        const [pre, post] = Types.Object.toQueriesAccsessors[options.arrayAccsessor || Types.Object.defaultToQueriesOptions.arrayAccsessor]\r\n                        accsessor = `${prefix}${pre}${post}`\r\n                    }\r\n                    else if(Guards.isObjectConstructor(obj)) {\r\n                        const [pre, post] = Types.Object.toQueriesAccsessors[options.objectAccsessor || Types.Object.defaultToQueriesOptions.objectAccsessor]\r\n                        accsessor = (prefix ? `${prefix}${pre}${accsessor}${post}` : accsessor);\r\n                    }\r\n                \r\n                    if(Guards.isTypeofObject(value)) {\r\n                        result.push(Object(value).toQueries(options, accsessor)) \r\n                    }\r\n                    else {\r\n                        result.push(`${accsessor}=${encodeURIComponent(`${value}`)}`)\r\n                    }\r\n                } \r\n                else {\r\n                    continue\r\n                }\r\n            }\r\n\r\n            result = result.filter(nonEmptyString)\r\n\r\n            result = ([] as string[]).concat.apply([] as string[], result)\r\n\r\n            return result.length ? result.join('&') : \"\"\r\n        }\r\n\r\n        return {\r\n            get,\r\n            toQueries\r\n        }\r\n    }\r\n\r\n    export function String<S extends string>(string: S) {\r\n        function hasQueryParams() {\r\n            return `${string}`.indexOf('?') !== -1;\r\n        }\r\n\r\n        function joinQueryString<Q extends string>(queryString: Q): S extends `${string}?${string}` ? `${S}&${Q}` : `${S}?${Q}` {\r\n            const isHasQueryParams = hasQueryParams()\r\n            return isHasQueryParams ? `${string}&${queryString}` : `${string}?${queryString}` as any\r\n        }\r\n\r\n        function split<Separator extends string>(separator: string, limit?: number | undefined): Types.String.Split<S, Separator> {\r\n            return `${string}`.split(separator, limit) as any\r\n        }\r\n\r\n        function replaceAllSeparatedString<P extends { [x: string]: any }, Separator extends string = string>\r\n        (separator: Separator, properties: P): Types.String.ReplaceAll<S, P> {\r\n            const result = []\r\n\r\n            const parts = split(separator)\r\n\r\n            for(let i = 0; i < parts.length; i++) {\r\n                const property = Base.Object<P>(properties).get(parts[i])\r\n\r\n                if(Base.Object<P>(properties).get(parts[i])) {\r\n                    result.push(property)\r\n                } else {\r\n                    result.push(parts[i])\r\n                }\r\n            }\r\n\r\n            return result.join(separator) as Types.String.ReplaceAll<S, P>\r\n        }\r\n        \r\n        return {\r\n            split,\r\n            replaceAllSeparatedString,\r\n            hasQueryParams,\r\n            joinQueryString\r\n        }\r\n    }\r\n}\r\n\r\nexport { Base }"]}