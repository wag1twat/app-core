{"version":3,"sources":["Base/Object/get-xpath.js","../src/Base/Object/get-xpath.ts"],"names":["__importDefault","mod","__esModule","Object","defineProperty","split_1","require","memoStringToPath","cache","path","default","stringToPath","getXPath","obj","keys","let","index","length","res","undefined","exports"],"mappings":"AAAA,aACA,IAAIA,gBAAoD,SAAUC,GAA9DD,OAAAA,GAAeC,EAAIC,WAAQD,EAAKD,CAAAA,QAAeC,CAAK,CAExD,EACAE,OAF6CC,eAAWH,QAAAA,aAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,ECDxD,MAAAI,QAAAL,gBAAAM,QAAA,iBAAA,CAAA,EAEMC,iBAAmBA,KACrB,MAAMC,EAAkC,GACxC,OAA0BC,IAClBD,EAAMC,KAGVD,EAAMC,IAAQ,EAAAJ,QAAAK,SAAMD,CAAI,EAAE,GAAG,GACtBD,EAAMC,GAErB,EAEME,aAAeJ,iBAAgB,EAE/BK,SAA8BC,GAE5BJ,IAEA,IAAMK,EAAOH,aAAgBF,CAAI,EAEjCM,IAAIC,EAAQ,EACRC,EAASH,EAAKG,OACdC,EAAWL,EAEf,KAAc,MAAPK,GAAeF,EAAQC,GAC1BC,EAAMA,EAAIJ,EAAKE,CAAK,KAGxB,OAAOA,GAASA,GAASC,EAASC,EAAOC,KAAAA,CAC7C,EAGJC,QAAAV,QAAeE","file":"get-xpath.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst split_1 = __importDefault(require(\"../String/split\"));\nconst memoStringToPath = () => {\n    const cache = {};\n    return (path) => {\n        if (cache[path]) {\n            return cache[path];\n        }\n        cache[path] = (0, split_1.default)(path)('.');\n        return cache[path];\n    };\n};\nconst stringToPath = memoStringToPath();\nconst getXPath = (obj) => {\n    return (path) => {\n        const keys = stringToPath(path);\n        let index = 0, length = keys.length, res = obj;\n        while (res != null && index < length) {\n            res = res[keys[index++]];\n        }\n        return index && index == length ? res : undefined;\n    };\n};\nexports.default = getXPath;\n","import { Types } from '../Types'\nimport split from '../String/split'\n\nconst memoStringToPath = () => {\n    const cache: Record<string, string[]> = {}\n    return <O extends object>(path: Types.Utility.JSONPath<O>) => {\n        if (cache[path]) {\n            return cache[path]\n        }\n        cache[path] = split(path)('.')\n        return cache[path]\n    }\n}\n\nconst stringToPath = memoStringToPath()\n\nconst getXPath = <O extends object>(obj: O) => {\n    return <Path extends Types.Utility.JSONPath<O>>(\n        path: Path\n    ): Types.Utility.JSONFind<O, Path> | undefined => {\n        const keys = stringToPath<O>(path)\n\n        let index = 0,\n            length = keys.length,\n            res: any = obj\n\n        while (res != null && index < length) {\n            res = res[keys[index++]]\n        }\n\n        return index && index == length ? res : (undefined as any)\n    }\n}\n\nexport default getXPath\n"]}