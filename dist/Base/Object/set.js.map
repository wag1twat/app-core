{"version":3,"sources":["Base/Object/set.js","../src/Base/Object/set.ts"],"names":["Object","defineProperty","exports","value","deep_path_1","require","Guards_1","isIndex","isNaN","parseInt","set","object","path","Guards","isObject","deep","deepPath","length","lastIndex","let","index","nested","objValue","key","newValue"],"mappings":"AAAA,aACAA,OAAOC,eAAeC,QAAS,aAAc,CAAEC,MAAO,CAAA,CAAK,CAAC,EAA5DH,QAAOC,IAAAA,KAAAA,ECDP,MAAAG,YAAAC,QAAA,qBAAA,EACAC,SAAAD,QAAA,cAAA,EAGA,SAASE,QAAQJ,GACb,MAAO,CAACK,MAAMC,SAASN,EAAiB,EAAE,CAAC,CAC/C,CAEA,SAASO,IAAsBC,GAC3B,OAAO,SAAwDC,EAAST,GACpE,GAAKG,SAAAO,OAAOC,SAASH,CAAM,EAA3B,CAIA,IAAMI,GAAO,EAAAX,YAAAY,UAAYJ,CAAI,EAEvBK,EAASF,EAAKE,OACdC,EAAYD,EAAS,EAE3BE,IAAIC,EAAQ,CAAC,EACTC,EAAiBV,EAErB,KAAiB,MAAVU,GAAkB,EAAED,EAAQH,GAAQ,CACvC,IAIUK,EAJJC,EAAMR,EAAKK,GACjBD,IAAIK,EAA6BrB,EAE7BiB,GAASF,IACHI,EAAWD,EAAOE,GAExBC,EAAWlB,SAAAO,OAAOC,SAASQ,CAAQ,EAAIA,EAAWf,QAAQQ,EAAKK,EAAQ,EAAE,EAAI,GAAK,IAEtFC,EAAOE,GAAuBC,EAC9BH,EAASA,EAAOE,EDRhB,CCfR,CA0BI,OAAOZ,CACX,CACJ,CAEST,QAAAQ,IAAAA","file":"set.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.set = void 0;\nconst deep_path_1 = require(\"../String/deep-path\");\nconst Guards_1 = require(\"../../Guards\");\nfunction isIndex(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction set(object) {\n    return function (path, value) {\n        if (!Guards_1.Guards.isObject(object)) {\n            return object;\n        }\n        const deep = (0, deep_path_1.deepPath)(path);\n        const length = deep.length;\n        const lastIndex = length - 1;\n        let index = -1;\n        let nested = object;\n        while (nested != null && ++index < length) {\n            const key = deep[index];\n            let newValue = value;\n            if (index != lastIndex) {\n                const objValue = nested[key];\n                newValue = Guards_1.Guards.isObject(objValue) ? objValue : isIndex(deep[index + 1]) ? [] : {};\n            }\n            nested[key] = newValue;\n            nested = nested[key];\n        }\n        return object;\n    };\n}\nexports.set = set;\n","import { deepPath } from '../String/deep-path'\nimport { Guards } from '../../Guards'\nimport { Keys, Path, PathValue } from '../types'\n\nfunction isIndex(value: unknown): value is number {\n    return !isNaN(parseInt(value as string, 10))\n}\n\nfunction set<O extends object>(object: O) {\n    return function <P extends Path<O>, V extends PathValue<O, P>>(path: P, value: V): O {\n        if (!Guards.isObject(object)) {\n            return object\n        }\n\n        const deep = deepPath<O>(path)\n\n        const length = deep.length\n        const lastIndex = length - 1\n\n        let index = -1\n        let nested: object = object\n\n        while (nested != null && ++index < length) {\n            const key = deep[index]\n            let newValue: V | never[] | {} = value\n\n            if (index != lastIndex) {\n                const objValue = nested[key as Keys<typeof nested>]\n\n                newValue = Guards.isObject(objValue) ? objValue : isIndex(deep[index + 1]) ? [] : {}\n            }\n            nested[key as Keys<object>] = newValue as (typeof nested)[Keys<object>]\n            nested = nested[key as Keys<object>]\n        }\n\n        return object\n    }\n}\n\nexport { set }\n"]}