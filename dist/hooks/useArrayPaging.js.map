{"version":3,"sources":["hooks/useArrayPaging.js","../src/hooks/useArrayPaging.ts"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","useArrayPaging","react_1","require","Base_1","props","pageSize","paginationSize","items","itemsRef","default","useRef","state","setState","useState","deepEqual","current","functions","useMemo","$Array","paging","page","onUpdate","nextState","prevState","assign"],"mappings":"AAAA,aACA,IAAIA,gBAAoD,SAAUC,GAA9DD,OAAAA,GAAeC,EAAIC,WAAQD,EAAKD,CAAAA,QAAeC,CAAK,CAExD,EACAE,OAF6CC,eAAWH,QAAAA,aAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAGxDI,QAH6DC,eAAA,KAAA,ECF7D,MAAAC,QAAAP,gBAAAQ,QAAA,OAAA,CAAA,EACAC,OAAAD,QAAA,SAAA,EAiBMF,eAAiCI,IACnC,KAAM,CAAEC,SAAAA,EAAUC,eAAAA,EAAgBC,MAAAA,EAAQ,EAAE,EAAKH,EAE3CI,EAAWP,QAAAQ,QAAMC,OAAYH,CAAK,EAClC,CAACI,EAAOC,GAAYX,QAAAQ,QAAMI,SAAQ,GAEnC,EAAAV,OAAAW,WAAUN,EAASO,QAASR,CAAK,IAClCC,EAASO,QAAUR,GAGjBS,EAAYf,QAAAQ,QAAMQ,QAAQ,KACrB,EAAAd,OAAAe,QAAOV,EAASO,OAAO,EAAEI,OAAO,CACnCC,KAAW,OAALT,GAAK,KAAA,IAALA,EAAK,KAAA,EAALA,EAAOS,KACbf,SAAAA,EACAC,eAAAA,EACAe,SAAWC,IACPV,EAAUW,IAAgB,EAAApB,OAAAW,WAAUS,EAAWD,CAAS,EAAgBC,EAAZD,CAAsB,CACtF,CDpBR,CCqBK,EACF,CAACjB,EAAUC,EAAgBE,EAASO,QAAQ,EAE/C,OAAOlB,OAAO2B,OAAOb,GAAU,GAAgDK,CAAS,CAC5F,EAGSjB,QAAAC,eAAAA","file":"useArrayPaging.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useArrayPaging = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst Base_1 = require(\"../Base\");\n// TODO: onMount props\nconst useArrayPaging = (props) => {\n    const { pageSize, paginationSize, items = [] } = props;\n    const itemsRef = react_1.default.useRef(items);\n    const [state, setState] = react_1.default.useState();\n    if (!(0, Base_1.deepEqual)(itemsRef.current, items)) {\n        itemsRef.current = items;\n    }\n    const functions = react_1.default.useMemo(() => {\n        return (0, Base_1.$Array)(itemsRef.current).paging({\n            page: state?.page,\n            pageSize,\n            paginationSize,\n            onUpdate: (nextState) => {\n                setState((prevState) => (!(0, Base_1.deepEqual)(prevState, nextState) ? nextState : prevState));\n            },\n        });\n    }, [pageSize, paginationSize, itemsRef.current]);\n    return Object.assign(state || {}, functions);\n};\nexports.useArrayPaging = useArrayPaging;\n","import React from 'react'\nimport { deepEqual, $Array, Types } from '../Base'\n\ninterface ArrayPagingProps<T extends any> {\n    pageSize: number\n    paginationSize: number\n    items: T[] | undefined\n}\n\ninterface ArrayPaging<T extends any> extends Types.Array.PagingCollection.State<T[]> {\n    updatePage: (page: number) => void\n    nextPage: () => void\n    prevPage: () => void\n    nextPaginationPage: () => void\n    prevPaginationPage: () => void\n}\n\n// TODO: onMount props\nconst useArrayPaging = <T extends any>(props: ArrayPagingProps<T>): ArrayPaging<T> => {\n    const { pageSize, paginationSize, items = [] } = props\n\n    const itemsRef = React.useRef<T[]>(items)\n    const [state, setState] = React.useState<Types.Array.PagingCollection.State<T[]>>()\n\n    if (!deepEqual(itemsRef.current, items)) {\n        itemsRef.current = items\n    }\n\n    const functions = React.useMemo(() => {\n        return $Array(itemsRef.current).paging({\n            page: state?.page,\n            pageSize,\n            paginationSize,\n            onUpdate: (nextState) => {\n                setState((prevState) => (!deepEqual(prevState, nextState) ? nextState : prevState))\n            },\n        })\n    }, [pageSize, paginationSize, itemsRef.current])\n\n    return Object.assign(state || ({} as Types.Array.PagingCollection.State<T[]>), functions)\n}\n\nexport type { ArrayPagingProps, ArrayPaging }\nexport { useArrayPaging }\n"]}