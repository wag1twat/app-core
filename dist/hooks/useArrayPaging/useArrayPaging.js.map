{"version":3,"sources":["hooks/useArrayPaging/useArrayPaging.js","../src/hooks/useArrayPaging/useArrayPaging.ts"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","useArrayPaging","react_1","require","Base_1","options","startsWith","pageSize","paginationSize","onMount","collection","collectionRef","default","useRef","pagingState","onPagingUpdate","useState","page","nextCollection","onCollectionUpdate","deepEqual","current","functions","useMemo","$Array","paging","nextState","prevState","prevCollection"],"mappings":"AAAA,aACA,IAAIA,gBAAoD,SAAUC,GAA9DD,OAAAA,GAAeC,EAAIC,WAAQD,EAAKD,CAAAA,QAAeC,CAAK,CAExD,EACAE,OAF6CC,eAAWH,QAAAA,aAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAGxDI,QAH6DC,eAAA,KAAA,ECF7D,MAAAC,QAAAP,gBAAAQ,QAAA,OAAA,CAAA,EACAC,OAAAD,QAAA,YAAA,EAeMF,eAAmCI,IACrC,KAAM,CAAEC,WAAAA,EAAYC,SAAAA,EAAUC,eAAAA,EAAgBC,QAAAA,EAASC,WAAAA,CAAU,EAAKL,EAEhEM,EAAgBT,QAAAU,QAAMC,OAAOH,CAAU,EAEvC,CAACI,EAAaC,GAAkBb,QAAAU,QAAMI,SAA4C,CACpFC,KAAMX,GAAc,CAN5B,CAOK,EAEK,CAACY,EAAgBC,GAAsBjB,QAAAU,QAAMI,SAAQ,GAEtD,EAAAZ,OAAAgB,WAAUT,EAAcU,QAASX,CAAU,IAC5CC,EAAcU,QAAUX,GAGtBY,EAAYpB,QAAAU,QAAMW,QAAQ,KACrB,EAAAnB,OAAAoB,QAAOb,EAAcU,OAAO,EAAEI,OAAO,CACxCnB,WAAuB,OAAXQ,GAAW,KAAA,IAAXA,EAAW,KAAA,EAAXA,EAAaG,KACzBV,SAAAA,EACAC,eAAAA,EACAC,QAAAA,EACAM,eAAiBW,GACbX,EAAgBY,IACX,EAAAvB,OAAAgB,WAAUO,EAAWD,CAAS,EAAqCC,EAAjC,CAAE,GAAGA,EAAW,GAAGD,CAAS,CAAc,EAErFP,mBAAqBD,GACjBC,EAAoBS,IACf,EAAAxB,OAAAgB,WAAUQ,EAAgBV,CAAc,EAAqBU,EAAjBV,CAA+B,CAhBvF,CAkBA,EACF,CAACP,EAAcU,QAAoB,OAAXP,GAAW,KAAA,IAAXA,EAAW,KAAA,EAAXA,EAAaG,KAAMV,EAAUC,EAAgBC,EAAQ,EAEhF,MAAO,CACH,GAAGK,EACH,GAAGQ,EACHZ,WAAYQ,CDnBhB,CCqBJ,EAGSlB,QAAAC,eAAAA","file":"useArrayPaging.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useArrayPaging = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst Base_1 = require(\"../../Base\");\nconst useArrayPaging = (options) => {\n    const { startsWith, pageSize, paginationSize, onMount, collection } = options;\n    const collectionRef = react_1.default.useRef(collection);\n    const [pagingState, onPagingUpdate] = react_1.default.useState({\n        page: startsWith || 1,\n    });\n    const [nextCollection, onCollectionUpdate] = react_1.default.useState();\n    if (!(0, Base_1.deepEqual)(collectionRef.current, collection)) {\n        collectionRef.current = collection;\n    }\n    const functions = react_1.default.useMemo(() => {\n        return (0, Base_1.$Array)(collectionRef.current).paging({\n            startsWith: pagingState?.page,\n            pageSize,\n            paginationSize,\n            onMount,\n            onPagingUpdate: (nextState) => onPagingUpdate((prevState) => !(0, Base_1.deepEqual)(prevState, nextState) ? { ...prevState, ...nextState } : prevState),\n            onCollectionUpdate: (nextCollection) => onCollectionUpdate((prevCollection) => !(0, Base_1.deepEqual)(prevCollection, nextCollection) ? nextCollection : prevCollection),\n        });\n    }, [collectionRef.current, pagingState?.page, pageSize, paginationSize, onMount]);\n    return {\n        ...pagingState,\n        ...functions,\n        collection: nextCollection,\n    };\n};\nexports.useArrayPaging = useArrayPaging;\n","import React from 'react'\nimport { deepEqual, $Array, Types } from '../../Base'\n\ntype ArrayPagingProps<T extends any[]> = Omit<\n    Types.Array.CreatePaging.Options<T>,\n    'onPagingUpdate' | 'onCollectionUpdate'\n> & {\n    collection: T\n}\ntype ArrayPaging<T extends any[]> = Types.Array.Paging.PagingMethods &\n    Partial<\n        Types.Array.Paging.State & {\n            collection: T\n        }\n    >\n\nconst useArrayPaging = <T extends any[]>(options: ArrayPagingProps<T>): ArrayPaging<T> => {\n    const { startsWith, pageSize, paginationSize, onMount, collection } = options\n\n    const collectionRef = React.useRef(collection)\n\n    const [pagingState, onPagingUpdate] = React.useState<Partial<Types.Array.Paging.State>>({\n        page: startsWith || 1,\n    })\n\n    const [nextCollection, onCollectionUpdate] = React.useState<T>()\n\n    if (!deepEqual(collectionRef.current, collection)) {\n        collectionRef.current = collection\n    }\n\n    const functions = React.useMemo(() => {\n        return $Array(collectionRef.current).paging({\n            startsWith: pagingState?.page,\n            pageSize,\n            paginationSize,\n            onMount,\n            onPagingUpdate: (nextState) =>\n                onPagingUpdate((prevState) =>\n                    !deepEqual(prevState, nextState) ? { ...prevState, ...nextState } : prevState\n                ),\n            onCollectionUpdate: (nextCollection) =>\n                onCollectionUpdate((prevCollection) =>\n                    !deepEqual(prevCollection, nextCollection) ? nextCollection : prevCollection\n                ),\n        })\n    }, [collectionRef.current, pagingState?.page, pageSize, paginationSize, onMount])\n\n    return {\n        ...pagingState,\n        ...functions,\n        collection: nextCollection,\n    }\n}\n\nexport type { ArrayPagingProps, ArrayPaging }\nexport { useArrayPaging }\n"]}