{"version":3,"sources":["hooks/useArraySort/useArraySort.js","../src/hooks/useArraySort/useArraySort.ts"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","useArraySort","react_1","require","Base_1","options","collection","order","orders","field","collectionRef","default","useRef","ordersRef","fieldRef","sortState","onSortUpdate","useState","deepEqual","current","functions","useMemo","$Array","sort","nextState","prevState"],"mappings":"AAAA,aACA,IAAIA,gBAAoD,SAAUC,GAA9DD,OAAAA,GAAeC,EAAIC,WAAQD,EAAKD,CAAAA,QAAeC,CAAK,CAExD,EACAE,OAF6CC,eAAWH,QAAAA,aAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA,EAGxDI,QAH6DC,aAAA,KAAA,ECF7D,MAAAC,QAAAP,gBAAAQ,QAAA,OAAA,CAAA,EACAC,OAAAD,QAAA,YAAA,EAcMF,aACFI,IAEA,KAAM,CAAEC,WAAAA,EAAYC,MAAAA,EAAOC,OAAAA,EAAQC,MAAAA,CAAK,EAAKJ,EAEvCK,EAAgBR,QAAAS,QAAMC,OAAON,CAAU,EACvCO,EAAYX,QAAAS,QAAMC,OAAOJ,CAAM,EAC/BM,EAAWZ,QAAAS,QAAMC,OAAOH,CAAK,EAE7B,CAACM,EAAWC,GAAgBd,QAAAS,QAAMM,SAA6C,EAAE,GAElF,EAAAb,OAAAc,WAAUR,EAAcS,QAASb,CAAU,IAC5CI,EAAcS,QAAUb,IAEvB,EAAAF,OAAAc,WAAUL,EAAUM,QAASX,CAAM,IACpCK,EAAUM,QAAUX,IAEnB,EAAAJ,OAAAc,WAAUJ,EAASK,QAASV,CAAK,IAClCK,EAASK,QAAUV,GAGjBW,EAAYlB,QAAAS,QAAMU,QAAQ,KACrB,EAAAjB,OAAAkB,QAAOZ,EAAcS,OAAO,EAAEI,KAAK,CACtChB,MAAAA,EACAC,OAAQK,EAAUM,QAClBV,MAAOK,EAASK,QAChBH,aAAeQ,GACXR,EAAcS,IACT,EAAArB,OAAAc,WAAUO,EAAWD,CAAS,EAAqCC,EAAjC,CAAE,GAAGA,EAAW,GAAGD,CAAS,CAAc,CDxB7F,CC0BK,EACF,CAACd,EAAcS,QAASN,EAAUM,QAASL,EAASK,QAASZ,EAAM,EAEtE,MAAO,CACH,GAAGQ,EACH,GAAGK,CAbH,CAeR,EAGSpB,QAAAC,aAAAA","file":"useArraySort.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useArraySort = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst Base_1 = require(\"../../Base\");\nconst useArraySort = (options) => {\n    const { collection, order, orders, field } = options;\n    const collectionRef = react_1.default.useRef(collection);\n    const ordersRef = react_1.default.useRef(orders);\n    const fieldRef = react_1.default.useRef(field);\n    const [sortState, onSortUpdate] = react_1.default.useState({});\n    if (!(0, Base_1.deepEqual)(collectionRef.current, collection)) {\n        collectionRef.current = collection;\n    }\n    if (!(0, Base_1.deepEqual)(ordersRef.current, orders)) {\n        ordersRef.current = orders;\n    }\n    if (!(0, Base_1.deepEqual)(fieldRef.current, field)) {\n        fieldRef.current = field;\n    }\n    const functions = react_1.default.useMemo(() => {\n        return (0, Base_1.$Array)(collectionRef.current).sort({\n            order,\n            orders: ordersRef.current,\n            field: fieldRef.current,\n            onSortUpdate: (nextState) => onSortUpdate((prevState) => !(0, Base_1.deepEqual)(prevState, nextState) ? { ...prevState, ...nextState } : prevState),\n        });\n    }, [collectionRef.current, ordersRef.current, fieldRef.current, order]);\n    return {\n        ...sortState,\n        ...functions,\n    };\n};\nexports.useArraySort = useArraySort;\n","import React from 'react'\nimport { $Array, deepEqual, Types } from '../../Base'\n\ninterface ArraySortProps<\n    T extends any[],\n    XPath extends Types.Utility.JSONPath<Types.Array.Of<T>> = Types.Utility.JSONPath<\n        Types.Array.Of<T>\n    >\n> extends Omit<Types.Array.Sort.Options<T, XPath>, 'onSortUpdate'> {\n    collection: T\n}\ninterface ArraySort<T extends any[]>\n    extends Types.Array.Sort.SortMethods<T>,\n        Partial<Types.Array.Sort.State<T>> {}\n\nconst useArraySort = <T extends any[], XPath extends Types.Utility.JSONPath<Types.Array.Of<T>>>(\n    options: ArraySortProps<T, XPath>\n): ArraySort<T> => {\n    const { collection, order, orders, field } = options\n\n    const collectionRef = React.useRef(collection)\n    const ordersRef = React.useRef(orders)\n    const fieldRef = React.useRef(field)\n\n    const [sortState, onSortUpdate] = React.useState<Partial<Types.Array.Sort.State<T>>>({})\n\n    if (!deepEqual(collectionRef.current, collection)) {\n        collectionRef.current = collection\n    }\n    if (!deepEqual(ordersRef.current, orders)) {\n        ordersRef.current = orders\n    }\n    if (!deepEqual(fieldRef.current, field)) {\n        fieldRef.current = field\n    }\n\n    const functions = React.useMemo(() => {\n        return $Array(collectionRef.current).sort({\n            order,\n            orders: ordersRef.current,\n            field: fieldRef.current,\n            onSortUpdate: (nextState) =>\n                onSortUpdate((prevState) =>\n                    !deepEqual(prevState, nextState) ? { ...prevState, ...nextState } : prevState\n                ),\n        })\n    }, [collectionRef.current, ordersRef.current, fieldRef.current, order])\n\n    return {\n        ...sortState,\n        ...functions,\n    }\n}\n\nexport type { ArraySortProps, ArraySort }\nexport { useArraySort }\n"]}